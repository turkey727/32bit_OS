;KBCは0x60に書き込まれた値をデータ、0x64に書き込まれた値をコマンドとして認識する

KBC_Data_Write:
;0x60ポートにデータを書き込む関数。引数には書き込むデータを設定

	push	bp
	mov	bp, sp

	push	cx
.10L:
;以下4行、入力バッファ内に既にデータがあるかの確認。ループを抜けた結果cxが0ならタイムアウトした(既にデータがあって書き込めない)ことを示す
	in	al, 0x64		;KBCステータスレジスタを読み込み、alに保存。今回はステータスレジスタのB1を使う。

	test	al, 0x02		;alと0b10でand演算。結果をZFに反映。ZFが1なら書き込み可能
	loopnz	.10L			;cxが0になるか、ZFが1になったら終了。それまでループ

	cmp	cx, 0			;cxと0を比較。cx==0ならZF=1
	jz	.20E			;もしZF=1なら(タイムアウトしたら)ジャンプ
	
	mov	al, [bp + 4]		;alに引数で渡されたデータを代入
	out	0x60, al		;0x60ポートに引数で渡されたデータを出力
.20E:

	mov	ax, cx			;戻り値にcxを設定。タイムアウト(失敗したら)0、
					;ポートへの書き込みが成功したら0以外の値を戻り値として返す

	pop	cx

	mov	sp, bp
	pop	bp
	
	ret
	
KBC_Data_Read:
;0x60ポートのデータを読み込み、指定したアドレスに保存する関数。引数には読み込んだデータを保存するアドレスを設定
	
	push	bp
	mov	bp, sp

	push	cx
.10L:
;以下4行、読み込むデータが出力バッファに存在するかの確認。ループを抜けた結果cxが0ならタイムアウトした(読み込むデータがない)ことを示す
	in	al, 0x64		;KBCステータスレジスタを読み込み、alに保存。今回はステータスレジスタのB0を使う。

	test	al, 0x01		;alと0b01でand演算。結果をZFに反映。ZFが0なら書き込み可能
	loopz	.10L			;cxが0になるか、ZFが0になったら終了。それまでループ

	cmp	cx, 0			;cxと0を比較。cx==0ならZF=1
	jz	.20E			;もしZF=1なら(タイムアウトしたら)ジャンプ

	mov	ah, 0x00		;ahをゼロクリア
	in	al, 0x60		;0x60ポートからalにデータを入力
	
	mov	di, [bp + 4]		;diに引数で渡されたアドレスを代入
	mov	[di + 0], ax		;引数で渡されたアドレスにax(読み込んだデータ)を代入
.20E:

	mov	ax, cx			;戻り値にcxを設定。タイムアウト(失敗したら)0、
					;ポートへの書き込みが成功したら0以外の値を戻り値として返す

	pop	cx

	mov	sp, bp
	pop	bp
	
	ret

KBC_Cmd_Write:
;0x64ポートにKBCコマンドを書き込み、KBC制御を行う関数。引数には書き込むコマンドを設定

	push	bp
	mov	bp, sp

	push	cx
.10L:
;以下4行、入力バッファ内に既にデータがあるかの確認。ループを抜けた結果cxが0ならタイムアウトした(既にデータがあって書き込めない)ことを示す
	in	al, 0x64		;KBCステータスレジスタを読み込み、alに保存。今回はステータスレジスタのB1を使う。

	test	al, 0x02		;alと0b10でand演算。結果をZFに反映。ZFが1なら書き込み可能
	loopnz	.10L			;cxが0になるか、ZFが1になったら終了。それまでループ

	cmp	cx, 0			;cxと0を比較。cx==0ならZF=1
	jz	.20E			;もしZF=1なら(タイムアウトしたら)ジャンプ
	
	mov	al, [bp + 4]		;alに引数で渡されたコマンドを代入
	out	0x64, al		;0x64ポートに引数で渡されたコマンドを出力
.20E:

	mov	ax, cx			;戻り値にcxを設定。タイムアウト(失敗したら)0、
					;ポートへの書き込みが成功したら0以外の値を戻り値として返す

	pop	cx

	mov	sp, bp
	pop	bp
	
	ret
